# P4 Deadlock: Solución con orden total
# Configuración: 2
# Fecha: Tue Sep  2 23:14:25 CST 2025
# Sistema: Linux Denil 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
# CPU: 13th Gen Intel(R) Core(TM) i9-13900HX

=== RUN 1 ===
Laboratorio 6 - Práctica 4: Deadlock y Corrección

==================================================
SOLUCIÓN 1: ORDEN TOTAL
==================================================
[Hilo 2] Iniciando con orden total (A -> B)
[Hilo 2] Solicitando mutex A...
[Hilo 2] ✓ Obtuvo mutex A
[Hilo 1] Iniciando con orden total (A -> B)
[Hilo 1] Solicitando mutex A...
[Hilo 2] Solicitando mutex B...
[Hilo 2] ✓ Obtuvo mutex B
[Hilo 2] Liberando mutex B
[Hilo 2] Liberando mutex A
[Hilo 2] ✓ Completado con orden total
[Hilo 1] ✓ Obtuvo mutex A
[Hilo 1] Solicitando mutex B...
[Hilo 1] ✓ Obtuvo mutex B
[Hilo 1] Liberando mutex B
[Hilo 1] Liberando mutex A
[Hilo 1] ✓ Completado con orden total
✓ Solución completada en 0.1105 segundos
Operaciones completadas: 2/2
Estado final - A: 30, B: 60

=== ANÁLISIS DE CONDICIONES DE COFFMAN ===
1. Exclusión mutua: ✓ (mutex no compartibles)
2. Hold and wait: ✓ (mantener A mientras espera B)
3. No preemption: ✓ (no se pueden quitar mutex por fuerza)
4. Circular wait: ✓ (T1 espera B, T2 espera A)

SOLUCIONES:
- Orden total: Elimina circular wait
- Trylock: Elimina hold and wait con timeout

=== RUN 2 ===
Laboratorio 6 - Práctica 4: Deadlock y Corrección

==================================================
SOLUCIÓN 1: ORDEN TOTAL
==================================================
[Hilo 2] Iniciando con orden total (A -> B)
[Hilo 2] Solicitando mutex A...
[Hilo 2] ✓ Obtuvo mutex A
[Hilo 1] Iniciando con orden total (A -> B)
[Hilo 1] Solicitando mutex A...
[Hilo 2] Solicitando mutex B...
[Hilo 2] ✓ Obtuvo mutex B
[Hilo 2] Liberando mutex B
[Hilo 2] Liberando mutex A
[Hilo 2] ✓ Completado con orden total
[Hilo 1] ✓ Obtuvo mutex A
[Hilo 1] Solicitando mutex B...
[Hilo 1] ✓ Obtuvo mutex B
[Hilo 1] Liberando mutex B
[Hilo 1] Liberando mutex A
[Hilo 1] ✓ Completado con orden total
✓ Solución completada en 0.1015 segundos
Operaciones completadas: 2/2
Estado final - A: 30, B: 60

=== ANÁLISIS DE CONDICIONES DE COFFMAN ===
1. Exclusión mutua: ✓ (mutex no compartibles)
2. Hold and wait: ✓ (mantener A mientras espera B)
3. No preemption: ✓ (no se pueden quitar mutex por fuerza)
4. Circular wait: ✓ (T1 espera B, T2 espera A)

SOLUCIONES:
- Orden total: Elimina circular wait
- Trylock: Elimina hold and wait con timeout

=== RUN 3 ===
Laboratorio 6 - Práctica 4: Deadlock y Corrección

==================================================
SOLUCIÓN 1: ORDEN TOTAL
==================================================
[Hilo 1] Iniciando con orden total (A -> B)
[Hilo 1] Solicitando mutex A...
[Hilo 1] ✓ Obtuvo mutex A
[Hilo 2] Iniciando con orden total (A -> B)
[Hilo 2] Solicitando mutex A...
[Hilo 1] Solicitando mutex B...
[Hilo 1] ✓ Obtuvo mutex B
[Hilo 1] Liberando mutex B
[Hilo 1] Liberando mutex A
[Hilo 1] ✓ Completado con orden total
[Hilo 2] ✓ Obtuvo mutex A
[Hilo 2] Solicitando mutex B...
[Hilo 2] ✓ Obtuvo mutex B
[Hilo 2] Liberando mutex B
[Hilo 2] Liberando mutex A
[Hilo 2] ✓ Completado con orden total
✓ Solución completada en 0.1018 segundos
Operaciones completadas: 2/2
Estado final - A: 30, B: 60

=== ANÁLISIS DE CONDICIONES DE COFFMAN ===
1. Exclusión mutua: ✓ (mutex no compartibles)
2. Hold and wait: ✓ (mantener A mientras espera B)
3. No preemption: ✓ (no se pueden quitar mutex por fuerza)
4. Circular wait: ✓ (T1 espera B, T2 espera A)

SOLUCIONES:
- Orden total: Elimina circular wait
- Trylock: Elimina hold and wait con timeout

=== RUN 4 ===
Laboratorio 6 - Práctica 4: Deadlock y Corrección

==================================================
SOLUCIÓN 1: ORDEN TOTAL
==================================================
[Hilo 1] Iniciando con orden total (A -> B)
[Hilo 1] Solicitando mutex A...
[Hilo 1] ✓ Obtuvo mutex A
[Hilo 2] Iniciando con orden total (A -> B)
[Hilo 2] Solicitando mutex A...
[Hilo 1] Solicitando mutex B...
[Hilo 1] ✓ Obtuvo mutex B
[Hilo 1] Liberando mutex B
[Hilo 1] Liberando mutex A
[Hilo 1] ✓ Completado con orden total
[Hilo 2] ✓ Obtuvo mutex A
[Hilo 2] Solicitando mutex B...
[Hilo 2] ✓ Obtuvo mutex B
[Hilo 2] Liberando mutex B
[Hilo 2] Liberando mutex A
[Hilo 2] ✓ Completado con orden total
✓ Solución completada en 0.1014 segundos
Operaciones completadas: 2/2
Estado final - A: 30, B: 60

=== ANÁLISIS DE CONDICIONES DE COFFMAN ===
1. Exclusión mutua: ✓ (mutex no compartibles)
2. Hold and wait: ✓ (mantener A mientras espera B)
3. No preemption: ✓ (no se pueden quitar mutex por fuerza)
4. Circular wait: ✓ (T1 espera B, T2 espera A)

SOLUCIONES:
- Orden total: Elimina circular wait
- Trylock: Elimina hold and wait con timeout

=== RUN 5 ===
Laboratorio 6 - Práctica 4: Deadlock y Corrección

==================================================
SOLUCIÓN 1: ORDEN TOTAL
==================================================
[Hilo 1] Iniciando con orden total (A -> B)
[Hilo 1] Solicitando mutex A...
[Hilo 1] ✓ Obtuvo mutex A
[Hilo 2] Iniciando con orden total (A -> B)
[Hilo 2] Solicitando mutex A...
[Hilo 1] Solicitando mutex B...
[Hilo 1] ✓ Obtuvo mutex B
[Hilo 1] Liberando mutex B
[Hilo 1] Liberando mutex A
[Hilo 1] ✓ Completado con orden total
[Hilo 2] ✓ Obtuvo mutex A
[Hilo 2] Solicitando mutex B...
[Hilo 2] ✓ Obtuvo mutex B
[Hilo 2] Liberando mutex B
[Hilo 2] Liberando mutex A
[Hilo 2] ✓ Completado con orden total
✓ Solución completada en 0.1261 segundos
Operaciones completadas: 2/2
Estado final - A: 30, B: 60

=== ANÁLISIS DE CONDICIONES DE COFFMAN ===
1. Exclusión mutua: ✓ (mutex no compartibles)
2. Hold and wait: ✓ (mantener A mientras espera B)
3. No preemption: ✓ (no se pueden quitar mutex por fuerza)
4. Circular wait: ✓ (T1 espera B, T2 espera A)

SOLUCIONES:
- Orden total: Elimina circular wait
- Trylock: Elimina hold and wait con timeout

