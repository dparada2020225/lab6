# Laboratorio 6 - Acceso a Recursos Compartidos con Pthreads

**Universidad del Valle de Guatemala**  
**CC3086 Programaci√≥n de Microprocesadores**  
**Ciclo 2 de 2025**

## Descripci√≥n

Este laboratorio implementa cinco pr√°cticas progresivas sobre sincronizaci√≥n y acceso seguro a recursos compartidos usando POSIX Threads (Pthreads) en C++17.

## Estructura del Proyecto

```
Lab06/
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ timing.hpp              # Temporizador para benchmarks
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ p1_counter.cpp          # Pr√°ctica 1: Race conditions
‚îÇ   ‚îú‚îÄ‚îÄ p2_ring.cpp             # Pr√°ctica 2: Buffer circular
‚îÇ   ‚îú‚îÄ‚îÄ p3_rw.cpp               # Pr√°ctica 3: Lectores/Escritores
‚îÇ   ‚îú‚îÄ‚îÄ p4_deadlock.cpp         # Pr√°ctica 4: Deadlock
‚îÇ   ‚îî‚îÄ‚îÄ p5_pipeline.cpp         # Pr√°ctica 5: Pipeline con barreras
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ run_all.sh              # Ejecuci√≥n completa
‚îÇ   ‚îú‚îÄ‚îÄ benchmark.sh            # Benchmarking automatizado
‚îÇ   ‚îî‚îÄ‚îÄ analyze_results.py      # An√°lisis de resultados
‚îú‚îÄ‚îÄ bin/                        # Ejecutables (generado)
‚îú‚îÄ‚îÄ data/                       # Archivos de datos (generado)
‚îú‚îÄ‚îÄ results/                    # Resultados benchmarks (generado)
‚îú‚îÄ‚îÄ Makefile                    # Sistema de compilaci√≥n
‚îî‚îÄ‚îÄ README.md                   # Este archivo
```

## Prerrequisitos

### Sistema Recomendado
- **Linux nativo** o **Windows 10/11 + WSL2 (Ubuntu 22.04+)**
- **GCC 9+** o **Clang 10+** con soporte C++17
- **Make** para automatizaci√≥n

### Instalaci√≥n de Dependencias

#### Ubuntu/Debian
```bash
sudo apt update
sudo apt install -y build-essential clang gdb valgrind python3 python3-pip
pip3 install pandas matplotlib  # Opcional para an√°lisis
```

#### Verificar Instalaci√≥n
```bash
g++ --version
clang++ --version
make --version
```

## Compilaci√≥n

### Compilaci√≥n B√°sica
```bash
# Compilar todos los programas
make all

# Limpiar archivos generados
make clean

# Ver reglas disponibles
make help
```

### Compilaci√≥n con Sanitizers (Debugging)
```bash
# ThreadSanitizer (detecta race conditions)
make tsan

# AddressSanitizer (detecta errores de memoria)
make asan
```

**‚ö†Ô∏è IMPORTANTE:** No usar sanitizers para benchmarks finales (a√±aden overhead significativo).

## Ejecuci√≥n

### Ejecuci√≥n R√°pida (Todas las Pr√°cticas)
```bash
# Hacer ejecutable el script
chmod +x scripts/run_all.sh

# Ejecutar todas las pr√°cticas
./scripts/run_all.sh
```

### Ejecuci√≥n Individual por Pr√°ctica

#### Pr√°ctica 1: Race Conditions en Contador
```bash
# Formato: ./bin/p1_counter [hilos] [iteraciones] [repeticiones]
./bin/p1_counter 4 1000000 1
./bin/p1_counter 8 500000 1

# Comparar diferentes enfoques:
# - NAIVE: Race condition intencional
# - MUTEX: Protecci√≥n con mutex
# - SHARDED: Contadores por hilo
# - ATOMIC: std::atomic<long>
```

#### Pr√°ctica 2: Buffer Circular Productor/Consumidor
```bash
# Formato: ./bin/p2_ring [productores] [consumidores] [items_por_productor]
./bin/p2_ring 2 2 100000    # Balanceado
./bin/p2_ring 4 1 50000     # M√∫ltiples productores
./bin/p2_ring 1 4 50000     # M√∫ltiples consumidores

# Usa pthread_mutex_t + pthread_cond_t
# Evita busy waiting y p√©rdida de datos
```

#### Pr√°ctica 3: Lectores/Escritores
```bash
# Formato: ./bin/p3_rw [hilos] [operaciones_por_hilo]
./bin/p3_rw 6 50000

# Compara pthread_rwlock_t vs pthread_mutex_t
# Eval√∫a proporciones 90/10, 70/30, 50/50 (lectura/escritura)
```

#### Pr√°ctica 4: Deadlock y Correcci√≥n
```bash
# Ejecutar todas las demostraciones
./bin/p4_deadlock

# O ejecutar individualmente:
./bin/p4_deadlock 1    # Demostraci√≥n de deadlock (‚ö†Ô∏è puede colgarse)
./bin/p4_deadlock 2    # Soluci√≥n: orden total
./bin/p4_deadlock 3    # Soluci√≥n: trylock + backoff
```

**‚ö†Ô∏è PRECAUCI√ìN:** La opci√≥n 1 puede generar deadlock real. Usar Ctrl+C si se cuelga.

#### Pr√°ctica 5: Pipeline con Barreras
```bash
./bin/p5_pipeline

# Pipeline de 3 etapas: Generador ‚Üí Filtro ‚Üí Reducer
# Sincronizaci√≥n con pthread_barrier_t
# Inicializaci√≥n con pthread_once_t
```

## Benchmarking Automatizado

### Ejecutar Benchmarks Completos
```bash
# Hacer ejecutable
chmod +x scripts/benchmark.sh

# Ejecutar benchmarks (5 repeticiones por configuraci√≥n)
./scripts/benchmark.sh

# Resultados guardados en results/
```

### An√°lisis de Resultados
```bash
# Hacer ejecutable
chmod +x scripts/analyze_results.py

# Analizar resultados
python3 scripts/analyze_results.py results/

# Genera:
# - Estad√≠sticas por configuraci√≥n
# - Comparativas entre enfoques
# - CSV con datos agregados
# - Gr√°ficos (si matplotlib disponible)
```

## Descripci√≥n de las Pr√°cticas

### Pr√°ctica 1: Race Conditions en Contador Global
**Objetivos:**
- Demostrar race conditions en incremento concurrente
- Comparar mutex vs sharding vs atomic
- Medir throughput y overhead de sincronizaci√≥n

**Puntos Clave:**
- Race condition causa p√©rdida de incrementos
- Mutex garantiza correcci√≥n pero reduce paralelismo
- Sharding evita contenci√≥n, requiere reduce
- std::atomic balance entre correcci√≥n y rendimiento

### Pr√°ctica 2: Buffer Circular MPMC
**Objetivos:**
- Implementar cola FIFO acotada thread-safe
- Usar condition variables para evitar busy waiting
- Manejar shutdown graceful sin p√©rdida de datos

**Puntos Clave:**
- pthread_cond_wait libera mutex at√≥micamente
- Usar while (no if) para spurious wakeups
- signal vs broadcast para eficiencia
- Pol√≠tica de terminaci√≥n limpia

### Pr√°ctica 3: Lectores/Escritores con RWLock
**Objetivos:**
- Comparar mutex vs rwlock en tabla hash
- Evaluar throughput seg√∫n proporci√≥n lectura/escritura
- Analizar starvation del escritor

**Puntos Clave:**
- RWLock permite m√∫ltiples lectores concurrentes
- Beneficioso cuando lecturas >> escrituras (‚â•70%)
- Overhead de rwlock puede ser contraproducente con muchas escrituras
- Considerar equidad entre lectores y escritores

### Pr√°ctica 4: Deadlock Cl√°sico y Soluciones
**Objetivos:**
- Reproducir deadlock con dos mutex y orden opuesto
- Implementar soluciones: orden total y trylock
- Analizar condiciones de Coffman

**Puntos Clave:**
- Deadlock requiere: exclusi√≥n mutua + hold&wait + no preemption + circular wait
- Orden total elimina circular wait
- trylock + backoff elimina hold&wait
- Detecci√≥n vs prevenci√≥n vs recuperaci√≥n

### Pr√°ctica 5: Pipeline Sincronizado con Barreras
**Objetivos:**
- Coordinar etapas de pipeline con barreras
- Usar pthread_once para inicializaci√≥n √∫nica
- Medir throughput por etapa

**Puntos Clave:**
- pthread_barrier_wait sincroniza todos los hilos
- pthread_once garantiza inicializaci√≥n √∫nica thread-safe
- Barreras vs colas: menor latencia, sincronizaci√≥n estricta
- Throughput limitado por etapa m√°s lenta

## Debugging y Verificaci√≥n

### Detectar Race Conditions
```bash
# Compilar con ThreadSanitizer
make tsan

# Ejecutar versi√≥n instrumentada
./bin/p1_counter_tsan 4 100000 1

# TSan reportar√° race conditions detectados
```

### Detectar Memory Errors
```bash
# Compilar con AddressSanitizer
make asan

# Ejecutar versi√≥n instrumentada
./bin/p2_ring_asan 2 2 10000
```

### Usar Valgrind (Alternativo)
```bash
# Helgrind para race conditions
valgrind --tool=helgrind ./bin/p1_counter 2 50000 1

# Memcheck para memory leaks
valgrind --tool=memcheck --leak-check=full ./bin/p2_ring 1 1 1000
```

### GDB para Deadlocks
```bash
# Compilar con debug info
g++ -g -pthread src/p4_deadlock.cpp -o bin/p4_deadlock_debug

# Si programa se cuelga, attach con GDB
gdb -p $(pgrep p4_deadlock)

# En GDB:
(gdb) info threads
(gdb) thread apply all bt
(gdb) thread 1
(gdb) bt
```

## Interpretaci√≥n de Resultados

### M√©tricas Importantes
- **Throughput**: Operaciones por segundo
- **Latencia**: Tiempo de respuesta
- **Correcci√≥n**: Ausencia de p√©rdidas/corrupciones
- **Escalabilidad**: Rendimiento vs n√∫mero de hilos
- **Fairness**: Distribuci√≥n equitativa de recursos

### Indicadores de Problemas
- **Throughput muy bajo**: Alta contenci√≥n
- **Resultados incorrectos**: Race conditions
- **Programa colgado**: Deadlock
- **Timeouts frecuentes**: Livelock o starvation
- **Memoria creciente**: Memory leaks

## Troubleshooting

### Problemas Comunes

#### Compilation Errors
```bash
# Error: pthread functions not found
# Soluci√≥n: Verificar flag -pthread
g++ -pthread src/programa.cpp -o bin/programa

# Error: C++17 features not available
# Soluci√≥n: Actualizar GCC/Clang o usar -std=gnu++17
```

#### Runtime Issues
```bash
# Programa se cuelga (posible deadlock)
# 1. Usar Ctrl+C para terminar
# 2. Ejecutar con timeout: timeout 30s ./programa
# 3. Debuggear con GDB

# Resultados inconsistentes (race conditions)
# 1. Ejecutar con ThreadSanitizer
# 2. Aumentar n√∫mero de iteraciones
# 3. Verificar secciones cr√≠ticas
```

#### Performance Issues
```bash
# Throughput muy bajo
# 1. Verificar contenci√≥n en mutex
# 2. Considerar alternativas (sharding, rwlock)
# 3. Optimizar granularidad de locks

# Escalabilidad pobre
# 1. Analizar false sharing
# 2. Balancear carga entre hilos
# 3. Usar herramientas de profiling
```

## Entregables

### C√≥digo Fuente (src/)
- ‚úÖ Programas C++ completos y comentados
- ‚úÖ Compilaci√≥n sin warnings
- ‚úÖ Manejo de errores robusto
- ‚úÖ Headers con informaci√≥n del autor

### Documentaci√≥n (docs/)
- üìÑ **PDF explicativo** (m√°x. 8 p√°ginas total)
  - Dise√±o y decisiones por pr√°ctica
  - Justificaci√≥n de sincronizaci√≥n
  - An√°lisis de resultados y gr√°ficas
  - Post mortems de fallos encontrados
- üé• **Video demostrativo** (‚â§ 6 minutos)
  - Ejecuci√≥n de cada pr√°ctica
  - Respuestas a preguntas gu√≠a
  - Justificaci√≥n de decisiones de dise√±o

### Benchmarks (results/)
- üìä **Scripts y CSV** con resultados reproducibles
- üìà **Gr√°ficas** de comparaci√≥n de rendimiento
- üîß **Comandos exactos** utilizados para benchmarks

## R√∫brica de Evaluaci√≥n (100 pts)

| Criterio | Puntos | Descripci√≥n |
|----------|--------|-------------|
| **Correctitud** | 30 | Ausencia de data races y deadlocks, funcionamiento correcto |
| **M√©tricas y An√°lisis** | 25 | Tablas, gr√°ficas, reproducibilidad, interpretaci√≥n |
| **Dise√±o y Rendimiento** | 20 | Elecci√≥n apropiada de primitivas de sincronizaci√≥n |
| **Calidad del C√≥digo** | 15 | Comentarios, modularidad, manejo de errores, estilo |
| **Documentaci√≥n** | 10 | Claridad y profesionalismo del PDF y video |

**Nota:** El video se utiliza como principal fuente de validaci√≥n.

## Consejos y Mejores Pr√°cticas

### Sincronizaci√≥n
- ‚úÖ Usar `while` (no `if`) con `pthread_cond_wait`
- ‚úÖ Evitar `volatile` como mecanismo de exclusi√≥n
- ‚úÖ Delimitar secciones cr√≠ticas al m√≠nimo
- ‚úÖ Liberar siempre recursos (destroy de mutex/cond/rwlock/barrier)
- ‚úÖ Documentar pol√≠ticas de equidad y shutdown

### Performance
- üöÄ No mezclar sanitizers con benchmarks finales
- üöÄ Ejecutar ‚â•5 repeticiones por configuraci√≥n
- üöÄ Reportar tiempo total, ops/segundo y desviaci√≥n est√°ndar
- üöÄ Mantener versiones unsafe y safe para comparaci√≥n

### Debugging
- üîç Usar ThreadSanitizer para detectar races
- üîç Validar con Helgrind cuando sea posible
- üîç Implementar logging detallado para debugging
- üîç Probar en diferentes n√∫meros de hilos

## Referencias

- [POSIX Threads Programming](https://computing.llnl.gov/tutorials/pthreads/)
- [GCC ThreadSanitizer](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)
- [Valgrind User Manual](https://valgrind.org/docs/manual/)
- [C++ Concurrency in Action](https://www.manning.com/books/c-plus-plus-concurrency-in-action)

---

**Universidad del Valle de Guatemala**  
**Facultad de Ingenier√≠a - Departamento de Ciencias de la Computaci√≥n**  
**CC3086 Programaci√≥n de Microprocesadores - Ciclo 2 de 2025**